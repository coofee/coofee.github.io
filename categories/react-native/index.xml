<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>React Native on Simple... </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://coofee.github.io/categories/react-native/</link>
    <language>en-us</language>
    <author>Coofee</author>
    
    <updated>Fri, 21 Jul 2017 18:35:56 CST</updated>
    
    <item>
      <title>upgrade app signature algorithm</title>
      <link>http://coofee.github.io/post/upgrade-app-signature-algorithm/</link>
      <pubDate>Fri, 21 Jul 2017 18:35:56 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/upgrade-app-signature-algorithm/</guid>
      <description>

&lt;h1 id=&#34;android-jarsigner-apksigner&#34;&gt;Android JarSigner &amp;amp; ApkSigner&lt;/h1&gt;

&lt;p&gt;参看&lt;a href=&#34;https://jaq.alibaba.com/blog.htm?id=65&#34;&gt;Shadows Everywhere漏洞浅析&lt;/a&gt;我们可以知道，SHA1签名已经不安全了，签名算法最好升级到SHA2或者其他算法。&lt;/p&gt;

&lt;h2 id=&#34;0x01-android支持的签名算法&#34;&gt;0x01 Android支持的签名算法&lt;/h2&gt;

&lt;p&gt;android 4.3之前不支持SHA1之外的其他签名算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb install -r /Users/zhaocongying/Downloads/notepad-sha256withrsa-sha256.apk
/Users/zhaocongying/Downloads/notepad-sha256withrsa-sha256.apk: 1 file pushed. 4.3 MB/s (62395 bytes in 0.014s)
	pkg: /data/local/tmp/notepad-sha256withrsa-sha256.apk
Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;There is security vs compatibility trade off a few might be interested in. Pre-4.3, Android did not support any signature algorithms except SHA1. With Android &amp;gt;= 4.3, SHA256 support was fixed, and SHA384, SHA512, and ECDSA were added (source). There are still android 2.3.3 (android-10) devices being sold, so anyone interested in backwards compatibility will have to heed this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/&#34;&gt;how-to-migrate-your-android-apps-signing-key&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;see bug fix&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://issuetracker.google.com/issues/36956587&#34;&gt;APKs signed using SHA256withRSA or with individual files hashed using SHA-256 fail to install&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x01-签名生成与查看&#34;&gt;0x01 签名生成与查看&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;生成keystore&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 2048 -sigalg SHA256withRSA -dname &amp;quot;cn=Test,ou=Test,c=CA&amp;quot; -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看APK的签名算法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;keytool -printcert -jarfile notepad-sha1withrsa-sha1.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看keystore&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;keytool -list -v -keystore test.keystore
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;jarsigner签名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -keystore mykeystore -storepass password -sigalg SHA256withRSA -digestalg SHA256 my.apk test 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;0x02-jarsigner与apksigner的区别&#34;&gt;0x02 jarsigner与apksigner的区别&lt;/h2&gt;

&lt;p&gt;jarsigner是jdk自带的工具，apksigner是android sdk自带的工具（build-tools 24.0.3+版本才拥有）。在android build-tools 24.0.3以前默认使用jarsigner对app进行签名，在24.0.3版本以及之后使用apksigner进行签名，其中apksigner签名算法根据android的最低版本的不同而不同，jarsigner则可以直接指定签名算法(见: 上面的jarsigner签名)。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;tool&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;minSdkVersion &amp;lt; 18&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;minSdkVersion &amp;gt;= 18&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA1withRSA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withRSA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA1withDSA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withDSA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withEC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;代码详见&lt;code&gt;com.android.apksig.internal.apk.v1.V1SchemeSigner&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static DigestAlgorithm getSuggestedSignatureDigestAlgorithm(PublicKey signingKey, int minSdkVersion)
  throws InvalidKeyException
{
  String keyAlgorithm = signingKey.getAlgorithm();
  if (&amp;quot;RSA&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 18) {
      return DigestAlgorithm.SHA1;
    }
    return DigestAlgorithm.SHA256;
  }
  if (&amp;quot;DSA&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 21) {
      return DigestAlgorithm.SHA1;
    }
    return DigestAlgorithm.SHA256;
  }
  if (&amp;quot;EC&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 18) {
      throw new InvalidKeyException(&amp;quot;ECDSA signatures only supported for minSdkVersion 18 and higher&amp;quot;);
    }
    return DigestAlgorithm.SHA256;
  }
  throw new InvalidKeyException(&amp;quot;Unsupported key algorithm: &amp;quot; + keyAlgorithm);
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/command-line/apksigner.html&#34;&gt;apksigner&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x03-升级签名算法为sha2&#34;&gt;0x03 升级签名算法为SHA2&lt;/h2&gt;

&lt;p&gt;综上所示，如果我们要升级签名算法为SHA2，则android app的minSdkVersion必须大于等于18。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果直接使用apksigner签名则需要同时升级buildToolsVersion的版本大于等于24.0.3&lt;/li&gt;
&lt;li&gt;如果使用jarsigner签名的话则直接指定签名算法即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0x04-遗留问题&#34;&gt;0x04 遗留问题&lt;/h2&gt;

&lt;p&gt;由于keystore未发生变化，所以使用不同签名算法的app是可以互相覆盖的，故而攻击者也可以使用旧版本的apk(使用SHA1)覆盖新版本apk(使用SHA2)继续进行攻击，所以为了避免被攻击者进行攻击的最好更换keystore，但是这样就没法覆盖安装了，哭&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>catch react native IllegalViewOperationException</title>
      <link>http://coofee.github.io/post/catch-react-native-IllegalViewOperationException/</link>
      <pubDate>Fri, 21 Jul 2017 17:44:38 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/catch-react-native-IllegalViewOperationException/</guid>
      <description>

&lt;h1 id=&#34;0x00-react-native-default-exception-handler&#34;&gt;0x00 React Native Default Exception Handler&lt;/h1&gt;

&lt;p&gt;React Native官方支持在生成&lt;code&gt;ReactInstanceManager&lt;/code&gt;时使用&lt;code&gt;NativeModuleCallExceptionHandler&lt;/code&gt;接口来设置自己的异常处理器，防止js/react-native代码异常导致native端直接崩溃，样例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()
                .setApplication(context.getApplicationContext())
                .addPackage(new MainReactPackage())
                .setInitialLifecycleState(LifecycleState.BEFORE_CREATE)
                .setNativeModuleCallExceptionHandler(new NativeModuleCallExceptionHandler {

			        @Override
			        public void handleException(Exception e) {
			        	// 自己处理react-native异常.
			        }
			    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0x01-com-facebook-react-uimanager-illegalviewoperationexception&#34;&gt;0x01 com.facebook.react.uimanager.IllegalViewOperationException&lt;/h1&gt;

&lt;p&gt;app发布到线上之后，仍然出现了少部分未能捕获的异常，堆栈信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.facebook.react.uimanager.IllegalViewOperationException
Trying to add unknown view tag: 500 detail: View tag:496 children(2): [ 497,498, ], viewsToAdd(1): [ [2,500], ],
1 com.facebook.react.uimanager.NativeViewHierarchyManager.manageChildren(NativeViewHierarchyManager.java:387)
2 com.facebook.react.uimanager.UIViewOperationQueue$ManageChildrenOperation.execute(UIViewOperationQueue.java:179)
3 com.facebook.react.uimanager.UIViewOperationQueue$2.run(UIViewOperationQueue.java:787)
4 com.facebook.react.uimanager.UIViewOperationQueue.flushPendingBatches(UIViewOperationQueue.java:843)
5 com.facebook.react.uimanager.UIViewOperationQueue.access$1600(UIViewOperationQueue.java:48)
6 com.facebook.react.uimanager.UIViewOperationQueue$DispatchUIFrameCallback.doFrameGuarded(UIViewOperationQueue.java:889)
7 com.facebook.react.uimanager.GuardedFrameCallback.doFrame(GuardedFrameCallback.java:31)
8 com.facebook.react.modules.core.ReactChoreographer$ReactChoreographerDispatcher.doFrame(ReactChoreographer.java:129)
9 com.facebook.react.modules.core.ChoreographerCompat$FrameCallback$1.doFrame(ChoreographerCompat.java:107)
10 android.view.Choreographer$CallbackRecord.run(Choreographer.java:798)
11 android.view.Choreographer.doCallbacks(Choreographer.java:603)
12 android.view.Choreographer.doFrame(Choreographer.java:571)
13 android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:786)
14 android.os.Handler.handleCallback(Handler.java:815)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从日志中可以看出，抛出的异常为&lt;code&gt;IllegalViewOperationException&lt;/code&gt;，该异常的继承链如下，可以发现该异常继承自&lt;code&gt;RuntimeException&lt;/code&gt;，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;IllegalViewOperationException -&amp;gt; JSApplicationCausedNativeException -&amp;gt; RuntimeException&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对比&lt;code&gt;GuardedFrameCallback&lt;/code&gt;的源代码，可以发现在&lt;code&gt;GuardedFrameCallback.doFrame&lt;/code&gt;方法中捕获了全部的&lt;code&gt;RuntimeException&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.facebook.react.uimanager;

public abstract class GuardedFrameCallback extends ChoreographerCompat.FrameCallback {

  @Override
  public final void doFrame(long frameTimeNanos) {
    try {
      doFrameGuarded(frameTimeNanos);
    } catch (RuntimeException e) {
      mReactContext.handleException(e);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步往下追踪，&lt;code&gt;ReactContext&lt;/code&gt;的&lt;code&gt;handleException()&lt;/code&gt;方法的源代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void handleException(RuntimeException e) {
	if (mCatalystInstance != null &amp;amp;&amp;amp;
	    !mCatalystInstance.isDestroyed() &amp;amp;&amp;amp;
	    mNativeModuleCallExceptionHandler != null) {
	  mNativeModuleCallExceptionHandler.handleException(e);
	} else {
	  throw e;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们先前已经设置了&lt;code&gt;NativeModuleCallExceptionHandler&lt;/code&gt;处理器；同时异常并没有被捕获到；可知出现异常时&lt;code&gt;mCatalystInstance&lt;/code&gt;要么为&lt;code&gt;null&lt;/code&gt;，要么已经销毁了。&lt;/p&gt;

&lt;h1 id=&#34;catch-illegalviewoperationexception&#34;&gt;Catch IllegalViewOperationException&lt;/h1&gt;

&lt;p&gt;为了捕获这个异常，我们的做法大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Aspect
public class ReactContextAspect {

    @Around(&amp;quot;execution (* com.facebook.react.bridge.ReactContext.handleException(..))&amp;quot;)
    public Object injectHandleException(ProceedingJoinPoint joinPoint) throws Throwable {
        try {
            joinPoint.proceed(joinPoint.getArgs());
		 } catch (Throwable e) {
            LOGGER.d(&amp;quot;ReactContextAspect&amp;quot;, &amp;quot;handleException&amp;quot;, e);
			// 上报错误
     	 }
        return null;
    }

    private static class ReactContextHandleException extends Throwable {
        public ReactContextHandleException(Throwable cause) {
            super(cause);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>android fetch add custom cookie</title>
      <link>http://coofee.github.io/post/android-fetch-add-custom-cookie/</link>
      <pubDate>Thu, 29 Jun 2017 11:14:50 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/android-fetch-add-custom-cookie/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;0x00-为react-native的网络请求添加公共cookie&#34;&gt;0x00 为React Native的网络请求添加公共Cookie&lt;/h1&gt;

&lt;p&gt;本文分析基于React Native &lt;strong&gt;0.44&lt;/strong&gt;版本分析。&lt;/p&gt;

&lt;p&gt;由于我们在使用React Native编写应用时，内部的网络请求均使用了&lt;code&gt;fetch&lt;/code&gt;函数，所以下面我们主要分析一下&lt;code&gt;fetch&lt;/code&gt;函数的整个调用流程。&lt;/p&gt;

&lt;h1 id=&#34;0x01-fetch追根溯源&#34;&gt;0x01 Fetch追根溯源&lt;/h1&gt;

&lt;p&gt;从React Native的源代码我们可以知道fetch函数最终也是由native端的&lt;code&gt;NetworkingModule.java&lt;/code&gt;（Android）或&lt;code&gt;RCTNetworking.mm&lt;/code&gt;（iOS）实现。&lt;/p&gt;

&lt;h2 id=&#34;1-其调用流程如下&#34;&gt;1. 其调用流程如下&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://coofee.github.io/android-fetch-add-custom-cookie/react-native-fetch-0.44.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-代码分析如下&#34;&gt;2. 代码分析如下&lt;/h2&gt;

&lt;h3 id=&#34;1-将fetch函数添加到全局变量&#34;&gt;1. 将fetch函数添加到全局变量&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;react-native/Libraries/Core/InitializeCore.js&lt;/code&gt;的全部变量&lt;code&gt;global&lt;/code&gt;中定义了&lt;code&gt;fetch&lt;/code&gt;函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Set up XHR
// The native XMLHttpRequest in Chrome dev tools is CORS aware and won&#39;t
// let you fetch anything from the internet
defineProperty(global, &#39;XMLHttpRequest&#39;, () =&amp;gt; require(&#39;XMLHttpRequest&#39;));
defineProperty(global, &#39;FormData&#39;, () =&amp;gt; require(&#39;FormData&#39;));

defineProperty(global, &#39;fetch&#39;, () =&amp;gt; require(&#39;fetch&#39;).fetch);
defineProperty(global, &#39;Headers&#39;, () =&amp;gt; require(&#39;fetch&#39;).Headers);
defineProperty(global, &#39;Request&#39;, () =&amp;gt; require(&#39;fetch&#39;).Request);
defineProperty(global, &#39;Response&#39;, () =&amp;gt; require(&#39;fetch&#39;).Response);
defineProperty(global, &#39;WebSocket&#39;, () =&amp;gt; require(&#39;WebSocket&#39;));

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-fetch函数的具体实现&#34;&gt;2. fetch函数的具体实现&lt;/h3&gt;

&lt;p&gt;扒取&lt;code&gt;fetch&lt;/code&gt;的源代码，我们可以发现&lt;code&gt;fetch&lt;/code&gt;是由&lt;code&gt;XMLHttpRequest&lt;/code&gt;实现，并调用&lt;code&gt;XMLHttpRequest.send()&lt;/code&gt;函数发起请求。&lt;/p&gt;

&lt;p&gt;同时react native将&lt;code&gt;fetch&lt;/code&gt;的&lt;code&gt;credentials:&#39;include&#39;&lt;/code&gt;属性转变成了&lt;code&gt;XMLHttpRequest&lt;/code&gt;的&lt;code&gt;withCredentials&lt;/code&gt;属性，所以下一步，我们只需要关注&lt;code&gt;XMLHttpRequest&lt;/code&gt;中&lt;code&gt;withCredentials&lt;/code&gt;如何处理即可。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;react-native/Libraries/Network/fetch.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&#39;use strict&#39;;

import &#39;whatwg-fetch&#39;;

module.exports = {fetch, Headers, Request, Response};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native/node_modules/whatwg-fetch/fetch.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || &#39;&#39;)
        }
        options.url = &#39;responseURL&#39; in xhr ? xhr.responseURL : options.headers.get(&#39;X-Request-URL&#39;)
        var body = &#39;response&#39; in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError(&#39;Network request failed&#39;))
      }

      xhr.ontimeout = function() {
        reject(new TypeError(&#39;Network request failed&#39;))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === &#39;include&#39;) {
        xhr.withCredentials = true
      }

      if (&#39;responseType&#39; in xhr &amp;amp;&amp;amp; support.blob) {
        xhr.responseType = &#39;blob&#39;
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === &#39;undefined&#39; ? null : request._bodyInit)
    })
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-xmlhttprequest具体实现&#34;&gt;3. XMLHttpRequest具体实现&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;XMLHttpRequest&lt;/code&gt;中将&lt;code&gt;withCredentials&lt;/code&gt;作为参数传递给&lt;code&gt;RCTNetworking.sendRequest()&lt;/code&gt;发起网络请求。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;react-native/Libraries/Network/XMLHttpRequest.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;send(data: any): void {
    if (this.readyState !== this.OPENED) {
      throw new Error(&#39;Request has not been opened&#39;);
    }
    if (this._sent) {
      throw new Error(&#39;Request has already been sent&#39;);
    }
    this._sent = true;
    const incrementalEvents = this._incrementalEvents ||
      !!this.onreadystatechange ||
      !!this.onprogress;

    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didSendNetworkData&#39;,
      (args) =&amp;gt; this.__didUploadProgress(...args)
    ));
    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didReceiveNetworkResponse&#39;,
      (args) =&amp;gt; this.__didReceiveResponse(...args)
    ));
    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didReceiveNetworkData&#39;,
      (args) =&amp;gt; this.__didReceiveData(...args)
    ));
    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didReceiveNetworkIncrementalData&#39;,
      (args) =&amp;gt; this.__didReceiveIncrementalData(...args)
    ));
    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didReceiveNetworkDataProgress&#39;,
      (args) =&amp;gt; this.__didReceiveDataProgress(...args)
    ));
    this._subscriptions.push(RCTNetworking.addListener(
      &#39;didCompleteNetworkResponse&#39;,
      (args) =&amp;gt; this.__didCompleteResponse(...args)
    ));

    let nativeResponseType = &#39;text&#39;;
    if (this._responseType === &#39;arraybuffer&#39; || this._responseType === &#39;blob&#39;) {
      nativeResponseType = &#39;base64&#39;;
    }

    invariant(this._method, &#39;Request method needs to be defined.&#39;);
    invariant(this._url, &#39;Request URL needs to be defined.&#39;);
    RCTNetworking.sendRequest(
      this._method,
      this._trackingName,
      this._url,
      this._headers,
      data,
      nativeResponseType,
      incrementalEvents,
      this.timeout,
      this.__didCreateRequest.bind(this),
      this.withCredentials
    );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来重头戏来了，&lt;code&gt;RCTNetworking&lt;/code&gt;在android和iOS两端的实现并不一致，在iOS端，发送网络请求时是包含&lt;code&gt;withCredentials&lt;/code&gt;这个参数的，但是在android端&lt;code&gt;withCredentials&lt;/code&gt;这个参数会被忽略（因为在&lt;code&gt;RCTNetworking.android.js&lt;/code&gt;中定义&lt;code&gt;sendRequest&lt;/code&gt;函数时并没有&lt;code&gt;withCredentials&lt;/code&gt;这个参数，所以即使调用放传递了这个参数，也会被忽略）。&lt;/p&gt;

&lt;p&gt;也就是说在iOS端使用fetch发送请求时，可以通过配置属性，灵活决定是否发送cookie；而在android端则会一直发送cookie
&lt;a href=&#34;https://github.com/facebook/react-native/issues/14063&#34;&gt;issue: withCredentials flag in XHRs should default to &amp;ldquo;true&amp;rdquo;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;react-native/Libraries/Network/RCTNetworking.ios.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  sendRequest(
    method: string,
    trackingName: string,
    url: string,
    headers: Object,
    data: RequestBody,
    responseType: &#39;text&#39; | &#39;base64&#39;,
    incrementalUpdates: boolean,
    timeout: number,
    callback: (requestId: number) =&amp;gt; any,
    withCredentials: boolean
  ) {
    const body = convertRequestBody(data);
    RCTNetworkingNative.sendRequest({
      method,
      url,
      data: {...body, trackingName},
      headers,
      responseType,
      incrementalUpdates,
      timeout,
      withCredentials
    }, callback);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native/Libraries/Network/RCTNetworking.android.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    sendRequest(
    method: string,
    trackingName: string,
    url: string,
    headers: Object,
    data: RequestBody,
    responseType: &#39;text&#39; | &#39;base64&#39;,
    incrementalUpdates: boolean,
    timeout: number,
    callback: (requestId: number) =&amp;gt; any
  ) {
    const body = convertRequestBody(data);
    if (body &amp;amp;&amp;amp; body.formData) {
      body.formData = body.formData.map((part) =&amp;gt; ({
        ...part,
        headers: convertHeadersMapToArray(part.headers),
      }));
    }
    const requestId = generateRequestId();
    RCTNetworkingNative.sendRequest(
      method,
      url,
      requestId,
      convertHeadersMapToArray(headers),
      {...body, trackingName},
      responseType,
      incrementalUpdates,
      timeout
    );
    callback(requestId);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-android端网络具体实现&#34;&gt;4. Android端网络具体实现&lt;/h3&gt;

&lt;p&gt;同样，我们可以看到在&lt;code&gt;com.facebook.react.modules.network.NetworkingModule.java&lt;/code&gt;中也没有&lt;code&gt;withCredentials&lt;/code&gt;相关处理，故而如果要保持android和iOS两端行为一致，则必须同时修改android+javascript两端代码才可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Override
public void initialize() {
	mCookieJarContainer.setCookieJar(new JavaNetCookieJar(mCookieHandler));
}

public void sendRequest(
  final ExecutorToken executorToken,
  String method,
  String url,
  final int requestId,
  ReadableArray headers,
  ReadableMap data,
  final String responseType,
  final boolean useIncrementalUpdates,
  int timeout) {
  
	Request.Builder requestBuilder = new Request.Builder().url(url);
	
	if (requestId != 0) {
	  requestBuilder.tag(requestId);
	}
	
	// 略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-ios端网络具体实现&#34;&gt;5. iOS端网络具体实现&lt;/h3&gt;

&lt;p&gt;可以看到在&lt;code&gt;react-native/Libraries/Network/RCTNetworking.mm&lt;/code&gt;文件中对&lt;code&gt;withCredentials&lt;/code&gt;进行了单独处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objective-c&#34;&gt;- (RCTURLRequestCancellationBlock)buildRequest:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)query
                                 completionBlock:(void (^)(NSURLRequest *request))block
{
  RCTAssertThread(_methodQueue, @&amp;quot;buildRequest: must be called on method queue&amp;quot;);

  NSURL *URL = [RCTConvert NSURL:query[@&amp;quot;url&amp;quot;]]; // this is marked as nullable in JS, but should not be null
  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  request.HTTPMethod = [RCTConvert NSString:RCTNilIfNull(query[@&amp;quot;method&amp;quot;])].uppercaseString ?: @&amp;quot;GET&amp;quot;;
  request.allHTTPHeaderFields = [self stripNullsInRequestHeaders:[RCTConvert NSDictionary:query[@&amp;quot;headers&amp;quot;]]];
  request.timeoutInterval = [RCTConvert NSTimeInterval:query[@&amp;quot;timeout&amp;quot;]];
  request.HTTPShouldHandleCookies = [RCTConvert BOOL:query[@&amp;quot;withCredentials&amp;quot;]];

  // 略...
  
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0x02-android端添加公共cookie&#34;&gt;0x02 Android端添加公共Cookie&lt;/h1&gt;

&lt;p&gt;从上面的分析，我们知道android端使用&lt;code&gt;NetworkingModule&lt;/code&gt;实现网络请求，同时在&lt;code&gt;NetworkingModule&lt;/code&gt;初始化的时候添加了CookieJar来处理Cookie，所以如果我们要添加Cookie，就必须从CookieJar入手。由于我们并不想修改React Native的源代码，所以可以通过在打包时修改字节码的方式来达到同样的效果，这里我们使用aspect，用自定义CookieJar替换&lt;code&gt;NetworkingModule&lt;/code&gt;原始的CookieJar达到添加公共cookie的目的.&lt;/p&gt;

&lt;p&gt;首先，&lt;code&gt;NetworkingModule&lt;/code&gt;是在&lt;code&gt;initialize()&lt;/code&gt;的时候初始化的CookieJar，所以我们将该方法作为我们的切入点，大致代码如下:&lt;/p&gt;

&lt;h2 id=&#34;1-添加aspect依赖&#34;&gt;1. 添加aspect依赖:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {
    classpath fileTree(dir:&#39;plugins&#39;, include:[&#39;*.jar&#39;])
    //don&#39;t lost dependency
    classpath &#39;org.aspectj:aspectjtools:1.8.+&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-添加切面&#34;&gt;2. 添加切面:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Aspect
public class NetworkingModuleAspect {

    @Around(&amp;quot;execution (* com.facebook.react.modules.network.NetworkingModule.initialize())&amp;quot;)
    public Object injectCustomCookie(ProceedingJoinPoint joinPoint) throws Throwable {
        Object networkingModule = joinPoint.getTarget();

        CookieJarContainer cookieJarContainer = (CookieJarContainer) getFieldValue(networkingModule, &amp;quot;mCookieJarContainer&amp;quot;);
        CookieHandler cookieHandler = (CookieHandler) getFieldValue(networkingModule, &amp;quot;mCookieHandler&amp;quot;);

        cookieJarContainer.setCookieJar(new JavaNetCookieJarWithCommonHeader(cookieHandler));

        return null;
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义CookieJar，在&lt;code&gt;loadForRequest()&lt;/code&gt;方法中添加公共Cookie，大致代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public static final class JavaNetCookieJarWithCommonHeader implements CookieJar {
    // 略...

    @Override
    public List&amp;lt;Cookie&amp;gt; loadForRequest(HttpUrl url) {
        // The RI passes all headers. We don&#39;t have &#39;em, so we don&#39;t pass &#39;em!
        List&amp;lt;Cookie&amp;gt; cookies = new ArrayList&amp;lt;Cookie&amp;gt;();

		  // add common cookie.
        Map&amp;lt;String, String&amp;gt; commonHeaders = CommonHeaderUtils.getInstance(null).get(url.toString());
        if (commonHeaders != null &amp;amp;&amp;amp; !commonHeaders.isEmpty()) {
            for (Map.Entry&amp;lt;String, String&amp;gt; entry : commonHeaders.entrySet()) {
                if (entry.getKey() == null) {
                    continue;
                }

                cookies.add(new Cookie.Builder()
                        .name(entry.getKey())
                        .value(entry.getValue() == null ? &amp;quot;&amp;quot; : entry.getValue())
                        .domain(url.host())
                        .build());
            }
        }

        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; headers = Collections.emptyMap();
        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; cookieHeaders;
        try {
            cookieHeaders = cookieHandler.get(url.uri(), headers);
        } catch (IOException e) {
            Platform.get().log(WARN, &amp;quot;Loading cookies failed for &amp;quot; + url.resolve(&amp;quot;/...&amp;quot;), e);
            return cookies;
        }

        for (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry : cookieHeaders.entrySet()) {
            String key = entry.getKey();
            if ((&amp;quot;Cookie&amp;quot;.equalsIgnoreCase(key) || &amp;quot;Cookie2&amp;quot;.equalsIgnoreCase(key))
                    &amp;amp;&amp;amp; !entry.getValue().isEmpty()) {
                for (String header : entry.getValue()) {
                    if (cookies == null) cookies = new ArrayList&amp;lt;&amp;gt;();
                    cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
                }
            }
        }

        return cookies != null
                ? Collections.unmodifiableList(cookies)
                : Collections.&amp;lt;Cookie&amp;gt;emptyList();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-配置aspect插件&#34;&gt;3. 配置aspect插件:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {
    repositories {
        mavenLocal()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.1.3&#39;
        classpath &#39;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:1.0.10&#39;

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Application项目中配置aspect插件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;android-aspectjx&#39;
aspectjx {
	//includes the libs that you want to weave
    includeJarFilter &#39;自己切面所在的库&#39;, &#39;react-native&#39;
    
    //excludes the libs that you don&#39;t want to weave
	excludeJarFilter &#39;universal-image-loader&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于aspectj插件的具体配置，可以参考&lt;a href=&#34;https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx&#34;&gt;android aspectjx plugin&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
