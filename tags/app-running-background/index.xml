<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>App Running Background on Simple... </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://coofee.github.io/tags/app-running-background/</link>
    <language>en-us</language>
    <author>Coofee</author>
    
    <updated>Tue, 25 Jul 2017 19:43:30 CST</updated>
    
    <item>
      <title>android check app running foreground</title>
      <link>http://coofee.github.io/post/android-check-app-running-foreground/</link>
      <pubDate>Tue, 25 Jul 2017 19:43:30 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/android-check-app-running-foreground/</guid>
      <description>

&lt;h2 id=&#34;0x00-使用application-activitylifecyclecallbacks检测app运行在前台-后台&#34;&gt;0x00 使用Application.ActivityLifecycleCallbacks检测App运行在前台/后台&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import android.app.Activity;
import android.app.ActivityManager;
import android.app.Application;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;

import java.util.List;


public class ApplicationLifecycle implements Application.ActivityLifecycleCallbacks {

    private Handler mHandler = new Handler();

    private Runnable mCheck = new Runnable() {
        @Override
        public void run() {
            Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;check task exec; mCounter=&amp;quot; + mCounter);

            if (mCounter == 0) {
                Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;check task exec; get runningAppProcessInfo.&amp;quot;);

                final ActivityManager am = (ActivityManager) mAppContext.getSystemService(Context.ACTIVITY_SERVICE);
                // NOTE: getRunningAppProcess() ONLY GIVE YOU THE PROCESS OF YOUR OWN PACKAGE IN ANDROID M
                // BUT THAT&#39;S ENOUGH HERE
                List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; runningAppProcesses = am.getRunningAppProcesses();
                boolean foreground = false;
                for (ActivityManager.RunningAppProcessInfo ai : am.getRunningAppProcesses()) {
                    // KILL OTHER PROCESS OF MINE
                    if (ai.uid == android.os.Process.myUid()
                            &amp;amp;&amp;amp; ai.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                        Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, ai.processName + &amp;quot; importance is IMPORTANCE_FOREGROUND.&amp;quot;);
                        foreground = true;
                        break;
                    }
                }

                if (foreground) {
                    Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;check task exec; background=false&amp;quot;);
                } else {
                 	Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;check task exec; background=true&amp;quot;);
                 }
            }
        }
    };


    private int mCounter = 0;
    private Context mAppContext = null;

    public ApplicationLifecycle(Context context) {
        mAppContext = context.getApplicationContext();
    }

    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

    }

    @Override
    public void onActivityStarted(Activity activity) {

    }

    @Override
    public void onActivityResumed(Activity activity) {
        mCounter++;
        Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;onActivityResumed mCounter=&amp;quot; + mCounter);
        mHandler.removeCallbacks(mCheck);
    }

    @Override
    public void onActivityPaused(Activity activity) {
        mCounter--;
        Log.e(&amp;quot;ApplicationLifecycle&amp;quot;, &amp;quot;onActivityPaused post check task; mCounter=&amp;quot; + mCounter);

        mHandler.removeCallbacks(mCheck);
        mHandler.postDelayed(mCheck, 2000);
    }

    @Override
    public void onActivityStopped(Activity activity) {

    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

    }

    @Override
    public void onActivityDestroyed(Activity activity) {

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;0x01-杀进程的各种方法&#34;&gt;0x01 杀进程的各种方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (Build.VERSION.SDK_INT &amp;gt;= 21) {
    finishAndRemoveTask();
}

if (Build.VERSION.SDK_INT &amp;gt;= 16) {
    finishAffinity();
}

ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
activityManager.killBackgroundProcesses(getPackageName());

android.os.Process.killProcess(android.os.Process.myPid());// kill process
System.exit(-1);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
