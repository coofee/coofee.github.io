<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>React Native on Simple... </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://coofee.github.io/tags/react-native/</link>
    <language>en-us</language>
    <author>Coofee</author>
    
    <updated>Fri, 21 Jul 2017 18:35:56 CST</updated>
    
    <item>
      <title>upgrade app signature algorithm</title>
      <link>http://coofee.github.io/post/upgrade-app-signature-algorithm/</link>
      <pubDate>Fri, 21 Jul 2017 18:35:56 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/upgrade-app-signature-algorithm/</guid>
      <description>

&lt;h1 id=&#34;android-jarsigner-apksigner&#34;&gt;Android JarSigner &amp;amp; ApkSigner&lt;/h1&gt;

&lt;p&gt;参看&lt;a href=&#34;https://jaq.alibaba.com/blog.htm?id=65&#34;&gt;Shadows Everywhere漏洞浅析&lt;/a&gt;我们可以知道，SHA1签名已经不安全了，签名算法最好升级到SHA2或者其他算法。&lt;/p&gt;

&lt;h2 id=&#34;0x01-android支持的签名算法&#34;&gt;0x01 Android支持的签名算法&lt;/h2&gt;

&lt;p&gt;android 4.3之前不支持SHA1之外的其他签名算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb install -r /Users/zhaocongying/Downloads/notepad-sha256withrsa-sha256.apk
/Users/zhaocongying/Downloads/notepad-sha256withrsa-sha256.apk: 1 file pushed. 4.3 MB/s (62395 bytes in 0.014s)
	pkg: /data/local/tmp/notepad-sha256withrsa-sha256.apk
Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;There is security vs compatibility trade off a few might be interested in. Pre-4.3, Android did not support any signature algorithms except SHA1. With Android &amp;gt;= 4.3, SHA256 support was fixed, and SHA384, SHA512, and ECDSA were added (source). There are still android 2.3.3 (android-10) devices being sold, so anyone interested in backwards compatibility will have to heed this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://guardianproject.info/2015/12/29/how-to-migrate-your-android-apps-signing-key/&#34;&gt;how-to-migrate-your-android-apps-signing-key&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;see bug fix&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://issuetracker.google.com/issues/36956587&#34;&gt;APKs signed using SHA256withRSA or with individual files hashed using SHA-256 fail to install&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x01-签名生成与查看&#34;&gt;0x01 签名生成与查看&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;生成keystore&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;keytool -genkey -v -keystore test.keystore -alias testkey -keyalg RSA -keysize 2048 -sigalg SHA256withRSA -dname &amp;quot;cn=Test,ou=Test,c=CA&amp;quot; -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看APK的签名算法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;keytool -printcert -jarfile notepad-sha1withrsa-sha1.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看keystore&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;keytool -list -v -keystore test.keystore
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;jarsigner签名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -keystore mykeystore -storepass password -sigalg SHA256withRSA -digestalg SHA256 my.apk test 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;0x02-jarsigner与apksigner的区别&#34;&gt;0x02 jarsigner与apksigner的区别&lt;/h2&gt;

&lt;p&gt;jarsigner是jdk自带的工具，apksigner是android sdk自带的工具（build-tools 24.0.3+版本才拥有）。在android build-tools 24.0.3以前默认使用jarsigner对app进行签名，在24.0.3版本以及之后使用apksigner进行签名，其中apksigner签名算法根据android的最低版本的不同而不同，jarsigner则可以直接指定签名算法(见: 上面的jarsigner签名)。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;tool&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;minSdkVersion &amp;lt; 18&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;minSdkVersion &amp;gt;= 18&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA1withRSA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withRSA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA1withDSA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withDSA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;apksigner&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256withEC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;代码详见&lt;code&gt;com.android.apksig.internal.apk.v1.V1SchemeSigner&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static DigestAlgorithm getSuggestedSignatureDigestAlgorithm(PublicKey signingKey, int minSdkVersion)
  throws InvalidKeyException
{
  String keyAlgorithm = signingKey.getAlgorithm();
  if (&amp;quot;RSA&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 18) {
      return DigestAlgorithm.SHA1;
    }
    return DigestAlgorithm.SHA256;
  }
  if (&amp;quot;DSA&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 21) {
      return DigestAlgorithm.SHA1;
    }
    return DigestAlgorithm.SHA256;
  }
  if (&amp;quot;EC&amp;quot;.equalsIgnoreCase(keyAlgorithm))
  {
    if (minSdkVersion &amp;lt; 18) {
      throw new InvalidKeyException(&amp;quot;ECDSA signatures only supported for minSdkVersion 18 and higher&amp;quot;);
    }
    return DigestAlgorithm.SHA256;
  }
  throw new InvalidKeyException(&amp;quot;Unsupported key algorithm: &amp;quot; + keyAlgorithm);
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/command-line/apksigner.html&#34;&gt;apksigner&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x03-升级签名算法为sha2&#34;&gt;0x03 升级签名算法为SHA2&lt;/h2&gt;

&lt;p&gt;综上所示，如果我们要升级签名算法为SHA2，则android app的minSdkVersion必须大于等于18。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果直接使用apksigner签名则需要同时升级buildToolsVersion的版本大于等于24.0.3&lt;/li&gt;
&lt;li&gt;如果使用jarsigner签名的话则直接指定签名算法即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0x04-遗留问题&#34;&gt;0x04 遗留问题&lt;/h2&gt;

&lt;p&gt;由于keystore未发生变化，所以使用不同签名算法的app是可以互相覆盖的，故而攻击者也可以使用旧版本的apk(使用SHA1)覆盖新版本apk(使用SHA2)继续进行攻击，所以为了避免被攻击者进行攻击的最好更换keystore，但是这样就没法覆盖安装了，哭&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>catch react native IllegalViewOperationException</title>
      <link>http://coofee.github.io/post/catch-react-native-IllegalViewOperationException/</link>
      <pubDate>Fri, 21 Jul 2017 17:44:38 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/catch-react-native-IllegalViewOperationException/</guid>
      <description>

&lt;h1 id=&#34;0x00-react-native-default-exception-handler&#34;&gt;0x00 React Native Default Exception Handler&lt;/h1&gt;

&lt;p&gt;React Native官方支持在生成&lt;code&gt;ReactInstanceManager&lt;/code&gt;时使用&lt;code&gt;NativeModuleCallExceptionHandler&lt;/code&gt;接口来设置自己的异常处理器，防止js/react-native代码异常导致native端直接崩溃，样例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()
                .setApplication(context.getApplicationContext())
                .addPackage(new MainReactPackage())
                .setInitialLifecycleState(LifecycleState.BEFORE_CREATE)
                .setNativeModuleCallExceptionHandler(new NativeModuleCallExceptionHandler {

			        @Override
			        public void handleException(Exception e) {
			        	// 自己处理react-native异常.
			        }
			    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;0x01-com-facebook-react-uimanager-illegalviewoperationexception&#34;&gt;0x01 com.facebook.react.uimanager.IllegalViewOperationException&lt;/h1&gt;

&lt;p&gt;app发布到线上之后，仍然出现了少部分未能捕获的异常，堆栈信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;com.facebook.react.uimanager.IllegalViewOperationException
Trying to add unknown view tag: 500 detail: View tag:496 children(2): [ 497,498, ], viewsToAdd(1): [ [2,500], ],
1 com.facebook.react.uimanager.NativeViewHierarchyManager.manageChildren(NativeViewHierarchyManager.java:387)
2 com.facebook.react.uimanager.UIViewOperationQueue$ManageChildrenOperation.execute(UIViewOperationQueue.java:179)
3 com.facebook.react.uimanager.UIViewOperationQueue$2.run(UIViewOperationQueue.java:787)
4 com.facebook.react.uimanager.UIViewOperationQueue.flushPendingBatches(UIViewOperationQueue.java:843)
5 com.facebook.react.uimanager.UIViewOperationQueue.access$1600(UIViewOperationQueue.java:48)
6 com.facebook.react.uimanager.UIViewOperationQueue$DispatchUIFrameCallback.doFrameGuarded(UIViewOperationQueue.java:889)
7 com.facebook.react.uimanager.GuardedFrameCallback.doFrame(GuardedFrameCallback.java:31)
8 com.facebook.react.modules.core.ReactChoreographer$ReactChoreographerDispatcher.doFrame(ReactChoreographer.java:129)
9 com.facebook.react.modules.core.ChoreographerCompat$FrameCallback$1.doFrame(ChoreographerCompat.java:107)
10 android.view.Choreographer$CallbackRecord.run(Choreographer.java:798)
11 android.view.Choreographer.doCallbacks(Choreographer.java:603)
12 android.view.Choreographer.doFrame(Choreographer.java:571)
13 android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:786)
14 android.os.Handler.handleCallback(Handler.java:815)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从日志中可以看出，抛出的异常为&lt;code&gt;IllegalViewOperationException&lt;/code&gt;，该异常的继承链如下，可以发现该异常继承自&lt;code&gt;RuntimeException&lt;/code&gt;，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;IllegalViewOperationException -&amp;gt; JSApplicationCausedNativeException -&amp;gt; RuntimeException&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对比&lt;code&gt;GuardedFrameCallback&lt;/code&gt;的源代码，可以发现在&lt;code&gt;GuardedFrameCallback.doFrame&lt;/code&gt;方法中捕获了全部的&lt;code&gt;RuntimeException&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.facebook.react.uimanager;

public abstract class GuardedFrameCallback extends ChoreographerCompat.FrameCallback {

  @Override
  public final void doFrame(long frameTimeNanos) {
    try {
      doFrameGuarded(frameTimeNanos);
    } catch (RuntimeException e) {
      mReactContext.handleException(e);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步往下追踪，&lt;code&gt;ReactContext&lt;/code&gt;的&lt;code&gt;handleException()&lt;/code&gt;方法的源代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void handleException(RuntimeException e) {
	if (mCatalystInstance != null &amp;amp;&amp;amp;
	    !mCatalystInstance.isDestroyed() &amp;amp;&amp;amp;
	    mNativeModuleCallExceptionHandler != null) {
	  mNativeModuleCallExceptionHandler.handleException(e);
	} else {
	  throw e;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们先前已经设置了&lt;code&gt;NativeModuleCallExceptionHandler&lt;/code&gt;处理器；同时异常并没有被捕获到；可知出现异常时&lt;code&gt;mCatalystInstance&lt;/code&gt;要么为&lt;code&gt;null&lt;/code&gt;，要么已经销毁了。&lt;/p&gt;

&lt;h1 id=&#34;catch-illegalviewoperationexception&#34;&gt;Catch IllegalViewOperationException&lt;/h1&gt;

&lt;p&gt;为了捕获这个异常，我们的做法大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Aspect
public class ReactContextAspect {

    @Around(&amp;quot;execution (* com.facebook.react.bridge.ReactContext.handleException(..))&amp;quot;)
    public Object injectHandleException(ProceedingJoinPoint joinPoint) throws Throwable {
        try {
            joinPoint.proceed(joinPoint.getArgs());
		 } catch (Throwable e) {
            LOGGER.d(&amp;quot;ReactContextAspect&amp;quot;, &amp;quot;handleException&amp;quot;, e);
			// 上报错误
     	 }
        return null;
    }

    private static class ReactContextHandleException extends Throwable {
        public ReactContextHandleException(Throwable cause) {
            super(cause);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
