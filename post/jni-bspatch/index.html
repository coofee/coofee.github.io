<!DOCTYPE HTML>

<html lang="en-us">

<head>
	<meta charset="utf-8">
	<title>android jni bspatch - Simple...</title>
	<meta name="author" content="map[name:Coofee email:coffeerene.zhao@gmail.com]">

	
	
	<meta name="description" content="">
	

	
	<meta name="HandheldFriendly" content="True">
	<meta name="MobileOptimized" content="320">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    
	<link href='/index.xml' rel="alternate" title="Simple..." type="application/atom+xml">
	
	<link rel="canonical" href="http://coofee.github.io/post/jni-bspatch/">
	<link href="http://coofee.github.io/favicon.png" rel="shortcut icon">
	<link href="http://coofee.github.io/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="http://coofee.github.io/css/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>

	
	<link href="http://coofee.github.io/css/prism.css" rel="stylesheet" />
	<script src="http://coofee.github.io/js/prism.js"></script>

	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	
	<script src="http://coofee.github.io/js/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5('coffeerene.zhao@gmail.com') + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/post/about">About</a></li>
    <li><a href="/post/">Archives</a></li>
</ul>

<section class="aboutme">
  <p>
    Less is more
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href='mailto:coffeerene.zhao@gmail.com' title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href='/index.xml' title="RSS">RSS</a>
		
	</div>
</nav>
</header>
			</div>
		</div>
		<div class="mid-col">
			
			<div class="mid-col-container">
				<div id="content" class="inner">
					<div itemscope itemtype="http://schema.org/Blog">
					<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <h1 class="title" itemprop="name">android jni bspatch</h1>
	<div class="entry-content" itemprop="articleBody">

<p>[TOC]</p>

<h2 id="1-下载并配置ndk">1. 下载并配置NDK:</h2>

<p><a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a></p>

<h2 id="2-编译bsdiff">2. 编译Bsdiff</h2>

<h3 id="2-1-编写java类-创建native方法">2.1 编写java类，创建native方法</h3>

<pre><code class="language-java">package com.commons.utils;
	
public class Bspatch {
	
    static {
        System.loadLibrary(&quot;bspatch&quot;);
    }
	
    public static native int applyPatch(String oldFile, String newFile, String patchFile);
	
}
</code></pre>

<h3 id="2-2-生成-h文件">2.2 生成.h文件</h3>

<ol>
<li><p>使用<strong>javac</strong>编写Bspatch或者在ide里面编译，这里我在android studio中编写并执行gradle的<strong>compileDebugJavaWithJavac</strong>任务进行编译，编译完成后，切换到classes目录。</p></li>

<li><p>使用javah生成.h文件</p></li>
</ol>

<pre><code class="language-bash">// 切换到编译好的类目录
cd app/build/intermediates/classes
// 生成.h文件
javah -d h -classpath debug com.commons.utils.Bspatch
	
</code></pre>

<h3 id="2-3-编译c-c-代码">2.3 编译c/c++代码.</h3>

<ol>
<li>复制生成的.h文件到c/c++文件目录.</li>
<li>在存放c/c++代码的目录中添加Android.mk、Application.mk文件。
其中Android.mk用于指定要编译的类，模块名称等；
Application.mk用于指定要生成特定abi类型的so文件，如：x86，armeabi等。</li>
</ol>

<p>目录结构如下：</p>

<blockquote>
<ul>
<li>app

<ul>
<li>build</li>
<li>jni

<ul>
<li>bspatch</li>
<li>bzip2</li>
<li>Android.mk</li>
<li>Application.mk</li>
<li>com_commons_utils_Bspatch.c</li>
<li>com_commons_utils_Bspatch.h</li>
</ul></li>
<li>libs</li>
<li>src</li>
<li>build.gradle</li>
<li>proguard-rules.pro
<br /></li>
</ul></li>
</ul>
</blockquote>

<ol>
<li>Android.mk内容如下：</li>
</ol>

<pre><code class="language-make">LOCAL_PATH := $(call my-dir)
	
include $(CLEAR_VARS)
	
# 指定模块名称
LOCAL_MODULE    := bspatch
# 添加源码
LOCAL_SRC_FILES := com_commons_utils_BsPatch.c
	
# for logging
LOCAL_LDLIBS    := -lz -llog
	
include $(BUILD_SHARED_LIBRARY)
	
</code></pre>

<ol>
<li>Application.mk</li>
</ol>

<pre><code>#表示生成全部abi的so
APP_ABI := all
	
</code></pre>

<ol>
<li>切换到jni目录，手动编译native代码。</li>
</ol>

<pre><code class="language-bash">$ cd app/jni
$ ndk-build
</code></pre>

<h2 id="3-修改bspatch代码">3. 修改bspatch代码</h2>

<ol>
<li>为了调用简单，这里直接修改了bspatch的main函数为patch函数，然后在jni函数中直接调用patch函数进行合并。
<br /></li>
</ol>

<pre><code class="language-c">	
#include &lt;android/log.h&gt;
	
#include &quot;bspatch/bspatch.c&quot;
	
#include &quot;com_commons_utils_Bspatch.h&quot;
	
	
	
/*
 * Class:     com_commons_utils_Bspatch
 * Method:    applyPatch
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_commons_utils_Bspatch_applyPatch
        (JNIEnv *env, jobject obj, jstring oldFile, jstring newFile, jstring patchFile) {
	
    int ret;
    char *ch[4];
    ch[0] = &quot;bspatch&quot;;
    ch[1] = (char *) ((*env)-&gt;GetStringUTFChars(env, oldFile, 0));
    ch[2] = (char *) ((*env)-&gt;GetStringUTFChars(env, newFile, 0));
    ch[3] = (char *) ((*env)-&gt;GetStringUTFChars(env, patchFile, 0));
	
    __android_log_print(ANDROID_LOG_INFO, &quot;bspatch&quot;, &quot;oldFile = %s &quot;, ch[1]);
    __android_log_print(ANDROID_LOG_INFO, &quot;bspatch&quot;, &quot;newFile = %s &quot;, ch[2]);
    __android_log_print(ANDROID_LOG_INFO, &quot;bspatch&quot;, &quot;patchFile = %s &quot;, ch[3]);
	
    ret = patch(4, ch);
    __android_log_print(ANDROID_LOG_INFO, &quot;bspatch&quot;, &quot;applypatch result = %d &quot;, ret);
	
    (*env)-&gt;ReleaseStringUTFChars(env, oldFile, ch[1]);
    (*env)-&gt;ReleaseStringUTFChars(env, newFile, ch[2]);
    (*env)-&gt;ReleaseStringUTFChars(env, patchFile, ch[3]);
    return ret;
}
	
</code></pre>

<ol>
<li>另由于在bspatch的代码中使用了err、errx函数，会导致出错时直接退出进程。为了在app中调用bspatch时不出现这种情况，所以使用自定义的err、errx函数替换系统err、errx函数，同时以返回值确定是否合并成功。</li>
</ol>

<pre><code class="language-c">    
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
// #include &lt;err.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;android/log.h&gt;
#include &lt;jni.h&gt;
    
#include &quot;../bzip2/bzlib.c&quot;
#include &quot;../bzip2/crctable.c&quot;
#include &quot;../bzip2/compress.c&quot;
#include &quot;../bzip2/decompress.c&quot;
#include &quot;../bzip2/randtable.c&quot;
#include &quot;../bzip2/blocksort.c&quot;
#include &quot;../bzip2/huffman.c&quot;
    
#include &lt;android/log.h&gt;
    
// #define vprintf(...) __android_log_print(ANDROID_LOG_DEBUG, &quot;bspatch&quot;, __VA_ARGS__);
    
static int err(int retVal, char* fmt, ...) {
    va_list arglist;
    va_start(arglist, fmt);
    // vprintf(fmt, arglist);
    __android_log_print(ANDROID_LOG_DEBUG, &quot;bspatch&quot;, fmt, arglist);
    va_end(arglist);
    return retVal;
}
    
static int errx(int retVal, char* fmt, ...) {
    va_list arglist;
    va_start(arglist, fmt);
    // vprintf(fmt, arglist);
    __android_log_print(ANDROID_LOG_DEBUG, &quot;bspatch&quot;, fmt, arglist);
    va_end(arglist);
    return retVal;
}
    
static void cleanup(FILE* f, FILE*  cpf, FILE*  dpf, FILE*  epf, 
    BZFILE* cpfbz2, BZFILE* dpfbz2, BZFILE* epfbz2, 
    u_char* old, u_char* new) {
    
    // close file and then free;
    if (f != NULL) {
        fclose(f);
        free(f);
    }
    
    if (cpf != NULL) {
        fclose(cpf);
        free(cpf);
    }
    
    if (dpf != NULL) {
        fclose(dpf);
        free(dpf);
    }
    
    if (epf != NULL) {
        fclose(epf);
        free(epf);
    }
    
    if (cpfbz2 != NULL) {
        BZ2_bzReadClose(NULL, cpfbz2);
    }
    
    if (dpfbz2 != NULL) {
        BZ2_bzReadClose(NULL, dpfbz2);
    }
    
    if (epfbz2 != NULL) {
        BZ2_bzReadClose(NULL, epfbz2);
    }
    
    if (old != NULL) {
        free(old);
    }
    
    if (new != NULL) {
        free(new);
    }
}
    
static off_t offtin(u_char *buf) {
    off_t y;
    
    y = buf[7] &amp; 0x7F;
    y = y * 256;
    y += buf[6];
    y = y * 256;
    y += buf[5];
    y = y * 256;
    y += buf[4];
    y = y * 256;
    y += buf[3];
    y = y * 256;
    y += buf[2];
    y = y * 256;
    y += buf[1];
    y = y * 256;
    y += buf[0];
    
    if (buf[7] &amp; 0x80)
        y = -y;
    
    return y;
}
    
static int patch(int argc, char *argv[]) {
    FILE *f, *cpf, *dpf, *epf;
    BZFILE *cpfbz2, *dpfbz2, *epfbz2;
    int cbz2err, dbz2err, ebz2err;
    int fd;
    ssize_t oldsize, newsize;
    ssize_t bzctrllen, bzdatalen;
    u_char header[32], buf[8];
    u_char *old, *new;
    off_t oldpos, newpos;
    off_t ctrl[3];
    off_t lenread;
    off_t i;
    
    if (argc != 4) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;usage: %s oldfile newfile patchfile\n&quot;, argv[0]);
    }
    
    /* Open patch file */
    if ((f = fopen(argv[3], &quot;r&quot;)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fopen(%s)&quot;, argv[3]);
    }
        
    
    /*
     File format:
     0  8   &quot;BSDIFF40&quot;
     8  8   X
     16 8   Y
     24 8   sizeof(newfile)
     32 X   bzip2(control block)
     32+X   Y   bzip2(diff block)
     32+X+Y ??? bzip2(extra block)
     with control block a set of triples (x,y,z) meaning &quot;add x bytes
     from oldfile to x bytes from the diff block; copy y bytes from the
     extra block; seek forwards in oldfile by z bytes&quot;.
     */
    
    /* Read header */
    if (fread(header, 1, 32, f) &lt; 32) {
        if (feof(f)) {
            errx(1, &quot;Corrupt patch\n&quot;);
        }
    
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fread(%s)&quot;, argv[3]);
    }
    
    /* Check for appropriate magic */
    if (memcmp(header, &quot;BSDIFF40&quot;, 8) != 0) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;Corrupt patch\n&quot;);
    }
    
    /* Read lengths from header */
    bzctrllen = offtin(header + 8);
    bzdatalen = offtin(header + 16);
    newsize = offtin(header + 24);
    if ((bzctrllen &lt; 0) || (bzdatalen &lt; 0) || (newsize &lt; 0)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;Corrupt patch\n&quot;);
    }
    
    /* Close patch file and re-open it via libbzip2 at the right places */
    if (fclose(f)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fclose(%s)&quot;, argv[3]);
    }
        
    if ((cpf = fopen(argv[3], &quot;r&quot;)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fopen(%s)&quot;, argv[3]);
    }
    
    if (fseeko(cpf, 32, SEEK_SET)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fseeko(%s, %lld)&quot;, argv[3], (long long) 32);
    }
    
    if ((cpfbz2 = BZ2_bzReadOpen(&amp;cbz2err, cpf, 0, 0, NULL, 0)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;BZ2_bzReadOpen, bz2err = %d&quot;, cbz2err);
    }
    
    if ((dpf = fopen(argv[3], &quot;r&quot;)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fopen(%s)&quot;, argv[3]);
    }
    if (fseeko(dpf, 32 + bzctrllen, SEEK_SET)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fseeko(%s, %lld)&quot;, argv[3], (long long) (32 + bzctrllen));
    }
    if ((dpfbz2 = BZ2_bzReadOpen(&amp;dbz2err, dpf, 0, 0, NULL, 0)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;BZ2_bzReadOpen, bz2err = %d&quot;, dbz2err);
    }
    if ((epf = fopen(argv[3], &quot;r&quot;)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fopen(%s)&quot;, argv[3]);
    }
    if (fseeko(epf, 32 + bzctrllen + bzdatalen, SEEK_SET)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fseeko(%s, %lld)&quot;, argv[3],
            (long long) (32 + bzctrllen + bzdatalen));
    }
    if ((epfbz2 = BZ2_bzReadOpen(&amp;ebz2err, epf, 0, 0, NULL, 0)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return errx(1, &quot;BZ2_bzReadOpen, bz2err = %d&quot;, ebz2err);
    }
    
    if (((fd = open(argv[1], O_RDONLY, 0)) &lt; 0)
        || ((oldsize = lseek(fd, 0, SEEK_END)) == -1)
        || ((old = malloc(oldsize + 1)) == NULL)
        || (lseek(fd, 0, SEEK_SET) != 0)
        || (read(fd, old, oldsize) != oldsize) || (close(fd) == -1)) {
        
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;%s&quot;, argv[1]);
    }
        
    if ((new = malloc(newsize + 1)) == NULL) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, NULL);
    }
    
    oldpos = 0;
    newpos = 0;
    while (newpos &lt; newsize) {
        /* Read control data */
        for (i = 0; i &lt;= 2; i++) {
            lenread = BZ2_bzRead(&amp;cbz2err, cpfbz2, buf, 8);
            if ((lenread &lt; 8)
                || ((cbz2err != BZ_OK) &amp;&amp; (cbz2err != BZ_STREAM_END))) {
                    cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
                    return errx(1, &quot;Corrupt patch\n&quot;);
                }
            ctrl[i] = offtin(buf);
        };
    
        /* Sanity-check */
        if (newpos + ctrl[0] &gt; newsize) {
            cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
            return errx(1, &quot;Corrupt patch\n&quot;);
        }
    
        /* Read diff string */
        lenread = BZ2_bzRead(&amp;dbz2err, dpfbz2, new + newpos, ctrl[0]);
        if ((lenread &lt; ctrl[0])
            || ((dbz2err != BZ_OK) &amp;&amp; (dbz2err != BZ_STREAM_END))) {
            cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
            return errx(1, &quot;Corrupt patch\n&quot;);
        }
    
        /* Add old data to diff string */
        for (i = 0; i &lt; ctrl[0]; i++)
            if ((oldpos + i &gt;= 0) &amp;&amp; (oldpos + i &lt; oldsize))
                new[newpos + i] += old[oldpos + i];
    
        /* Adjust pointers */
        newpos += ctrl[0];
        oldpos += ctrl[0];
    
        /* Sanity-check */
        if (newpos + ctrl[1] &gt; newsize) {
            cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
            return errx(1, &quot;Corrupt patch\n&quot;);
        }
    
        /* Read extra string */
        lenread = BZ2_bzRead(&amp;ebz2err, epfbz2, new + newpos, ctrl[1]);
        if ((lenread &lt; ctrl[1])
            || ((ebz2err != BZ_OK) &amp;&amp; (ebz2err != BZ_STREAM_END))) {
            cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
            return errx(1, &quot;Corrupt patch\n&quot;);
        }
    
        /* Adjust pointers */
        newpos += ctrl[1];
        oldpos += ctrl[2];
    };
    
    /* Clean up the bzip2 reads */
    BZ2_bzReadClose(&amp;cbz2err, cpfbz2);
    BZ2_bzReadClose(&amp;dbz2err, dpfbz2);
    BZ2_bzReadClose(&amp;ebz2err, epfbz2);
    if (fclose(cpf) || fclose(dpf) || fclose(epf)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;fclose(%s)&quot;, argv[3]);
    }
    
    /* Write the new file */
    if (((fd = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0666)) &lt; 0)
        || (write(fd, new, newsize) != newsize) || (close(fd) == -1)) {
        cleanup(f, cpf, dpf, epf, cpfbz2, dpfbz2, epfbz2, old, new);
        return err(1, &quot;%s&quot;, argv[2]);
    }
    
    free(new);
    free(old);
    
    return 0;
}
    
</code></pre>
</div></article>
					
						<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size=''></a>
	
	
	</div>
	
  	<script type="text/javascript" src='http://s7.addthis.com/js/250/addthis_widget.js#pubid='></script>
  	
</div>

					
					
					<section id="comment">
					    <h1 class="title">Comments</h1>
					    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
					</section>
					
					

<script type="text/javascript">
    
    var disqus_shortname = 'coofee-github-io';

    
    

    
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
    
</script>


				    </div>
				</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2018

    Coofee

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
<script src="http://coofee.github.io/js/slash.js"></script>
<script src="http://coofee.github.io/js/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script></footer>
		</div>
	</div>
	
</body>
</html>
