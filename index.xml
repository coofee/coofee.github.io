<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Simple... </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://coofee.github.io/</link>
    <language>en-us</language>
    <author>Coofee</author>
    
    <updated>Mon, 11 Jul 2016 23:07:37 CST</updated>
    
    <item>
      <title>hugo help</title>
      <link>http://coofee.github.io/post/hugo-help/</link>
      <pubDate>Mon, 11 Jul 2016 23:07:37 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/hugo-help/</guid>
      <description>

&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;

&lt;h2 id=&#34;1-1-发布到本地预览网站&#34;&gt;1.1 发布到本地预览网站&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ hugo server --theme=greyshade --buildDrafts --watch

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-发布网站到github&#34;&gt;1.2 发布网站到github&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ hugo  --theme=greyshade --buildDrafts
$ cd public
$ git add * 
$ git commit -a -m &#39;add all&#39;
$ git push origin master

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>groovy replace method</title>
      <link>http://coofee.github.io/post/groovy-replace-method/</link>
      <pubDate>Thu, 30 Jun 2016 00:04:39 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/groovy-replace-method/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;groovy-动态代理即替换方法&#34;&gt;Groovy 动态代理即替换方法&lt;/h1&gt;

&lt;p&gt;我们知道在Java中可以使用以下几种方法替换方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;JDK自带的动态代理只支持修改某个类所实现的接口的方法。java只支持单继承，所有的代理类都是Proxy的子类，所以只能覆盖接口的方法。&lt;/li&gt;
&lt;li&gt;asm直接修改字节码，直接修改字节码，直接修改类的方法和所实现接口的方法。&lt;/li&gt;
&lt;li&gt;javassist直接修改字节码，直接修改类的方法和所实现接口的方法。&lt;/li&gt;
&lt;li&gt;cglib基于asm封装，直接修改类的方法和所实现接口的方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总的来说，使用jdk自带的方案有局限，使用第三方框架能够支持全部功能。下面我们就来看一下，groovy作为一门jvm语言如何更加方便的实现动态代理的。&lt;/p&gt;

&lt;h2 id=&#34;1-1-演示类&#34;&gt;1.1 演示类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;class ReplaceMethod {
    
    // 用于演示替换实例方法
    public List&amp;lt;String&amp;gt; getStreamInputs() {
        List&amp;lt;String&amp;gt; strings = &amp;quot;a, b, c, d&amp;quot;.split(&amp;quot;, &amp;quot;);
        return strings;
    }

    // 用于演示替换泛型方法，同时演示如何区分同名的方法。
    public void genericMethod(List&amp;lt;String&amp;gt; strings) {
        println strings
    }

    public void genericMethod(List&amp;lt;String&amp;gt; strings, boolean num) {
        println strings
    }

}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-如何替换方法&#34;&gt;2 如何替换方法？&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过metaClass的&lt;code&gt;pickMethod&lt;/code&gt;获取到原始的方法引用。&lt;/li&gt;
&lt;li&gt;使用闭包替换metaClass上要替换的方法即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;样例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def repalceMethod = new ReplaceMethod();
println repalceMethod.getStreamInputs();
def oldMethod = ReplaceMethod.metaClass.&amp;amp;pickMethod(&#39;getStreamInputs&#39;, (Class[]) null)
repalceMethod.metaClass.getStreamInputs = {
    println &amp;quot;replaced&amp;quot;
    // 执行旧方法.
    println oldMethod.invoke(repalceMethod);
    List&amp;lt;String&amp;gt; strings = &amp;quot;1, 2, 3, 4&amp;quot;.split(&amp;quot;, &amp;quot;);
    return strings;
}
println repalceMethod.getStreamInputs()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-通过class的meta直接替换方法&#34;&gt;2.1 通过class的meta直接替换方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;Class.forName(&#39;com.coffee.groovy.metaclass.ReplaceMethod&#39;).metaClass.invokeMethod = { name, args -&amp;gt;
    println &amp;quot;replaced: Called ${name} with ${args}&amp;quot;
    println args.length
    println args.class
    println args.metaClass
    // http://stackoverflow.com/questions/10125903/groovy-overriding-invokemethod-for-a-single-instance
    delegate.class.metaClass.getMetaMethod(name, args)?.invoke(delegate, args)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-替换泛型方法-替换同名方法&#34;&gt;2.2 替换泛型方法&amp;amp;替换同名方法&lt;/h3&gt;

&lt;p&gt;通过指定要替换的方法的参数类型，既可以通过&lt;code&gt;pickMethod&lt;/code&gt;获取到对应的正确函数。对泛型而言，无需指定其具体的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;List&amp;lt;Class&amp;gt; argClasses = [];
argClasses.add(List.class)
argClasses.add(boolean.class)
println argClasses
def clazz = Class.forName(&#39;com.coffee.groovy.metaclass.ReplaceMethod&#39;);
def oldGenericMethod = clazz.metaClass.&amp;amp;pickMethod(&#39;genericMethod&#39;,
        argClasses.toArray(new Class[0]))
clazz.metaClass.genericMethod = { strings, result -&amp;gt;
    println &amp;quot;replaced: $strings : $result&amp;quot;
}

repalceMethod.genericMethod(&amp;quot;ac, sd, dc, dd&amp;quot;.split(&amp;quot;, &amp;quot;), true)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>如何科学上网</title>
      <link>http://coofee.github.io/post/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
      <pubDate>Fri, 25 Mar 2016 13:14:08 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
      <description>

&lt;h2 id=&#34;1-如何使用shadowsocks代理访问网络&#34;&gt;1. 如何使用shadowsocks代理访问网络？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;购买代理服务器，安装shadowsocks。&lt;/li&gt;
&lt;li&gt;本机安装shadowsocks-gui，然后添加代理服务器上shadowsocks的配置，此时shadowsocks会在本机上面开启一个socks代理，其默认端口是: 1080。&lt;/li&gt;
&lt;li&gt;打开shadowsocks，勾选代理服务器，同时勾选shadowsocks-gui的全局模式或者自动代理模式，然后在浏览器上面选择使用系统代理即可正常访问google。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-如何在mac的terminal中使用socks代理&#34;&gt;2. 如何在mac的Terminal中使用socks代理？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用homebrew安装proxychains4-ng&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建&lt;code&gt;~/.proxychains/proxychains.conf&lt;/code&gt;文件，文件内容如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strict_chain
proxy_dns
remote_dns_subnet 224
tcp_read_time_out 15000
tcp_connect_time_out 8000
localnet 127.0.0.0/255.0.0.0
quiet_mode

[ProxyList]
socks5  127.0.0.1 1080
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Terminal中，使用&lt;code&gt;proxychains4 [cmd]&lt;/code&gt;就可以使用代理服务器了。如：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;~$ proxychains4 brew update&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于mac osx 10.11，由于apple新增了sip模式，需要进入到Recovery模式(&lt;strong&gt;cmmand+R&lt;/strong&gt;)，然后在terminal中执行&lt;code&gt;csrutil enable --without debug&lt;/code&gt;命令，然后重启电脑，即可正常使用proxychains4-ng。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-如何让socks代理支持http代理&#34;&gt;3. 如何让socks代理支持http代理？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装polipo：&lt;code&gt;brew install polipo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看配置参数：&lt;code&gt;polipo -v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动http代理：&lt;code&gt;polipo socksParentProxy=localhost:1080&lt;/code&gt;，其默认端口是8123。&lt;/li&gt;
&lt;li&gt;此时其他应该程序就可以设置polipo的http代理：&lt;code&gt;localhost:8123&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-如何在terminal中使用http代理&#34;&gt;4. 如何在Terminal中使用Http代理？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;~/.bash_profile&lt;/code&gt;文件中添加以下代码，然后执行&lt;code&gt;source ~/.bash_profile&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias gaproxy=&#39;export http_proxy=127.0.0.1:8123 https_proxy=127.0.0.1:8123&#39;
alias noproxy=&#39;unset http_proxy https_proxy&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当使用http代理时，执行gaproxy，然后执行其他命令即可。如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~$ gaproxy
~$ curl www.google.com
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用时，可以直接执行noproxy。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://coofee.github.io/post/about/</link>
      <pubDate>Tue, 15 Mar 2016 19:51:21 CST</pubDate>
      <author>Coofee</author>
      <guid>http://coofee.github.io/post/about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
